/* NativeStaticGLState -*- mode: java; c-basic-offset: 2; -*- */
/*
 * Copyright (C) 2021 JFW
 *
 * # History
 *
 * - API derived from from GLSurfaceView.  Must not create its own
 * rendering thread; it is not safe to call into Gambit from multiple
 * threads unless no threads or asynchronous i/o is done in Gambit.
 *
 * - Stripped down to API, keeping comments mostly for documentation.
 *
 * # License
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * Neither the name of the University of British Columbia nor
 * the names of its contributors may be used to endorse or
 * promote products derived from this software without specific
 * prior written permission.

 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
 * CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * In case of conflict the follwoing licens shall apply:
 *
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package @SYS_PACKAGE_DOT@;

// import android.compat.annotation.UnsupportedAppUsage;
import android.content.Context;
import android.os.Trace;
import android.util.AttributeSet;
import android.util.Log;
import android.view.SurfaceHolder;
import android.view.SurfaceView;

import java.io.Writer;
import java.lang.ref.WeakReference;
import java.util.ArrayList;

import javax.microedition.khronos.egl.EGL10;
import javax.microedition.khronos.egl.EGL11;
import javax.microedition.khronos.egl.EGLConfig;
import javax.microedition.khronos.egl.EGLContext;
import javax.microedition.khronos.egl.EGLDisplay;
import javax.microedition.khronos.egl.EGLSurface;
import javax.microedition.khronos.opengles.GL;
import javax.microedition.khronos.opengles.GL10;

import android.opengl.GLDebugHelper;
import android.opengl.EGLExt;
import android.opengl.EGL14;

/**
 * <h3>Using NativeGLSurfaceView</h3>
 * <p>
 * Typically you use NativeGLSurfaceView by subclassing it and overriding one or more of the
 * View system input event methods. If your application does not need to override event
 * methods then NativeGLSurfaceView can be used as-is. For the most part
 * NativeGLSurfaceView behavior is customized by calling "set" methods rather than by subclassing.
 * For example, unlike a regular View, drawing is delegated to a separate Renderer object which
 * is registered with the NativeGLSurfaceView
 * using the {@link #setRenderer(Renderer)} call.
 *
 * Note: Those set methods are likely to be removed.
 *
 * <p>
 * <h3>Initializing NativeGLSurfaceView</h3>
 * All you have to do to initialize a NativeGLSurfaceView is call {@link #setRenderer(Renderer)}.
 * However, if desired, you can modify the default behavior of NativeGLSurfaceView by calling one or
 * more of these methods before calling setRenderer:
 * <ul>
 * <li>{@link #setDebugFlags(int)}
 * <li>{@link #setEGLConfigChooser(boolean)}
 * <li>{@link #setEGLConfigChooser(EGLConfigChooser)}
 * <li>{@link #setEGLConfigChooser(int, int, int, int, int, int)}
 * <li>{@link #setGLWrapper(GLWrapper)}
 * </ul>
 * <p>
 * <h4>Specifying the android.view.Surface</h4>
 * By default NativeGLSurfaceView will create a PixelFormat.RGB_888 format surface. If a translucent
 * surface is required, call getHolder().setFormat(PixelFormat.TRANSLUCENT).
 * The exact format of a TRANSLUCENT surface is device dependent, but it will be
 * a 32-bit-per-pixel surface with 8 bits per component.
 * <p>
 * <h4>Choosing an EGL Configuration</h4>
 * A given Android device may support multiple EGLConfig rendering configurations.
 * The available configurations may differ in how many channels of data are present, as
 * well as how many bits are allocated to each channel. Therefore, the first thing
 * NativeGLSurfaceView has to do when starting to render is choose what EGLConfig to use.
 * <p>
 * By default NativeGLSurfaceView chooses a EGLConfig that has an RGB_888 pixel format,
 * with at least a 16-bit depth buffer and no stencil.
 * <p>
 * If you would prefer a different EGLConfig
 * you can override the default behavior by calling one of the
 * setEGLConfigChooser methods.
 * <p>
 * <h4>Debug Behavior</h4>
 * You can optionally modify the behavior of NativeGLSurfaceView by calling
 * one or more of the debugging methods {@link #setDebugFlags(int)},
 * and {@link #setGLWrapper}. These methods may be called before and/or after setRenderer, but
 * typically they are called before setRenderer so that they take effect immediately.
 * <p>
 * <h4>Setting a Renderer</h4>
 * Finally, you must call {@link #setRenderer} to register a {@link Renderer}.
 * The renderer is
 * responsible for doing the actual OpenGL rendering.
 */

/* ****************************************** */

/**
 * A generic GL State.
 *
 * - Bookkeeping of initializing EGL and GL.
 *
 * - IMPORTANT: MUST ONLY be called from (native) thread doing the
 *   OpenGL drawing!
 *
 * - FIXME (do we need this?): Delegates to a Renderer instance to
 * do the actual drawing. Can be configured to render continuously
 * or on request.
 *
 * All potentially blocking synchronization is done through the
 * sGLStateManager object.
 */
/*
 *  FIXME TBD: replace GLStateManager with synchronisation
 *  primitive guarding native thread state.
 */
class GLState {
  private static final GLStateManager sGLStateManager = new GLStateManager();
  private final static String TAG = "NativeGLSurfaceView->GLState";
  private final static boolean LOG_THREADS = false;
  private final static boolean LOG_PAUSE_RESUME = false;
  private final static boolean LOG_SURFACE = false;
  /*
  private final static boolean LOG_ATTACH_DETACH = false;
  */
  private final static boolean LOG_RENDERER = false;
  private final static boolean LOG_RENDERER_DRAW_FRAME = false;
  private final static boolean LOG_EGL = false;
  // mOwnerThread thread allowed to mutate this state.  When null,
  // any thread may assume ownership.
  Thread mOwnerThread = null;

  /*
   * cache IDs when a class is loaded, and automatically re-cache them
   * if the class is ever unloaded and reloaded: use a class
   * initializer to allow the native code to cache some field
   * offsets. This native function looks up and caches interesting
   * class/field/method IDs. Throws on failure.
   */
  private static native void nativeInit();
  static {
    nativeInit();
  }

  private native void nativeOnNewObject();
  GLState(WeakReference<NativeGLSurfaceView> glSurfaceViewWeakRef) {
    super();
    nativeOnNewObject();
    mWidth = 0;
    mHeight = 0;
    mRequestRender = true;
    mRenderMode = NativeGLSurfaceView.RENDERMODE_CONTINUOUSLY;
    mWantRenderNotification = false;
    mNativeGLSurfaceViewWeakRef = glSurfaceViewWeakRef;
  }
  private GL10 gl = null;
  private boolean createEglContext = false;
  private boolean createEglSurface = false;
  private boolean createGlInterface = false;
  private boolean lostEglContext = false;
  private boolean sizeChanged = false;
  private boolean wantRenderNotification = false;
  private boolean doRenderNotification = false;
  private boolean askedToReleaseEglContext = false;
  private int w = 0;
  private int h = 0;
  private Runnable event = null;
  private Runnable finishDrawingRunnable = null;
  public void fromNativeStart() {
    if(LOG_PAUSE_RESUME) {
      Log.i("GLState", "fromNativeStart()");
    }
    // Must be called from OwnerThread once.
    if(mOwnerThread!=null) return;
    Thread cur = Thread.currentThread();
    cur.setName("GLState Owner " + cur.getId());
    if (LOG_EGL) {
      Log.i("GLState", "fromNativeStart() tid=" + cur.getName());
    }
    mOwnerThread = cur;
    mEglHelper = new EglHelper(mNativeGLSurfaceViewWeakRef);
    mHaveEglContext = false;
    mHaveEglSurface = false;
    mWantRenderNotification = false;

    // TBD: what are these good for?
    gl = null;
    createEglContext = false;
    createEglSurface = false;
    createGlInterface = false;
    lostEglContext = false;
    sizeChanged = false;
    wantRenderNotification = false;
    doRenderNotification = false;
    askedToReleaseEglContext = false;
    w = 0;
    h = 0;
    event = null;
    finishDrawingRunnable = null;
  }
  public void finalize() {
    /*
     * clean-up everything...
     */
    synchronized (sGLStateManager) {
      stopEglSurfaceLocked();
      stopEglContextLocked();
    }
  }
  /*
   * This private method should only be called inside a
   * synchronized(sGLStateManager) block.
   */
  private void stopEglSurfaceLocked() {
    if (mHaveEglSurface) {
      mHaveEglSurface = false;
      mEglHelper.destroySurface();
    }
  }
  /*
   * This private method should only be called inside a
   * synchronized(sGLStateManager) block.
   */
  private void stopEglContextLocked() {
    if (mHaveEglContext) {
      mEglHelper.finish();
      mHaveEglContext = false;
      sGLStateManager.releaseEglContextLocked(this);
    }
  }
  /*
   * Usage from native thread via JNI:
   * - fromNativeInitDraw();
   * - draw native
   * - fromNativeOnDrawFrame();
   * - fromNativeSwapBuffers();
   */
  private void fromNativeInitDraw() {
    while (true) {
      if(LOG_RENDERER) {
        Log.i("GLState", "fromNativeInitDraw tid=" + Thread.currentThread().getName());
      }
      synchronized (sGLStateManager) {
        while (true) {
          if(LOG_RENDERER) {
            Log.i("GLState", "fromNativeInitDraw in monitor tid=" + Thread.currentThread().getName() + " then " + mFinishDrawingRunnable + " and " + finishDrawingRunnable);
          }
          if (mShouldExit) {
            return;
          }
          if (! mEventQueue.isEmpty()) {
            event = mEventQueue.remove(0);
            break;
          }
          // Update the pause state.
          boolean pausing = false;
          if (mPaused != mRequestPaused) {
            pausing = mRequestPaused;
            mPaused = mRequestPaused;
            sGLStateManager.notifyAll();
            if (LOG_PAUSE_RESUME) {
              Log.i("GLState", "mPaused is now " + mPaused + " tid=" + mOwnerThread.getId());
            }
          }
          // Do we need to give up the EGL context?
          if (mShouldReleaseEglContext) {
            if (LOG_SURFACE) {
              Log.i("GLState", "releasing EGL context because asked to tid=" + mOwnerThread.getId());
            }
            stopEglSurfaceLocked();
            stopEglContextLocked();
            mShouldReleaseEglContext = false;
            askedToReleaseEglContext = true;
          }
          // Have we lost the EGL context?
          if (lostEglContext) {
            stopEglSurfaceLocked();
            stopEglContextLocked();
            lostEglContext = false;
          }
          // When pausing, release the EGL surface:
          if (pausing && mHaveEglSurface) {
            if (LOG_SURFACE) {
              Log.i("GLState", "releasing EGL surface because paused tid=" + mOwnerThread.getId());
            }
            stopEglSurfaceLocked();
          }
          // When pausing, optionally release the EGL Context:
          if (pausing && mHaveEglContext) {
            NativeGLSurfaceView view = mNativeGLSurfaceViewWeakRef.get();
            boolean preserveEglContextOnPause = view == null ?
              false : view.getPreserveEGLContextOnPause();
            if (!preserveEglContextOnPause) {
              stopEglContextLocked();
              if (LOG_SURFACE) {
                Log.i("GLState", "releasing EGL context because paused tid=" + mOwnerThread.getId());
              }
            }
          }
          // Have we lost the SurfaceView surface?
          if ((! mHasSurface) && (! mWaitingForSurface)) {
            if (LOG_SURFACE) {
              Log.i("GLState", "noticed surfaceView surface lost tid=" + mOwnerThread.getId());
            }
            if (mHaveEglSurface) {
              stopEglSurfaceLocked();
            }
            mWaitingForSurface = true;
            mSurfaceIsBad = false;
            sGLStateManager.notifyAll();
          }
          // Have we acquired the surface view surface?
          if (mHasSurface && mWaitingForSurface) {
            if (LOG_SURFACE) {
              Log.i("GLState", "noticed surfaceView surface acquired tid=" + mOwnerThread.getId());
            }
            mWaitingForSurface = false;
            sGLStateManager.notifyAll();
          }
          if (mFinishDrawingRunnable != null) {
            if(LOG_THREADS) {
              Log.i("GLState", "finishDrawingRunnable = mFinishDrawingRunnable");
            }
            finishDrawingRunnable = mFinishDrawingRunnable;
            mFinishDrawingRunnable = null;
          }
          // Ready to draw?
          if (readyToDraw()) {
            // If we don't have an EGL context, try to acquire one.
            if (! mHaveEglContext) {
              if (askedToReleaseEglContext) {
                askedToReleaseEglContext = false;
              } else {
                try {
                  mEglHelper.start();
                } catch (RuntimeException t) {
                  sGLStateManager.releaseEglContextLocked(this);
                  throw t;
                }
                mHaveEglContext = true;
                createEglContext = true;
                sGLStateManager.notifyAll();
              }
            }
            if (mHaveEglContext && !mHaveEglSurface) {
              mHaveEglSurface = true;
              createEglSurface = true;
              createGlInterface = true;
              sizeChanged = true;
            }
            if (mHaveEglSurface) {
              if (mSizeChanged) {
                sizeChanged = true;
                w = mWidth;
                h = mHeight;
                mWantRenderNotification = true;
                if (LOG_SURFACE) {
                  Log.i("GLState",
                        "noticing that we want render notification tid="
                        + mOwnerThread.getId());
                }
                // Destroy and recreate the EGL surface.
                createEglSurface = true;
                mSizeChanged = false;
              }
              mRequestRender = false;
              sGLStateManager.notifyAll();
              if (mWantRenderNotification) {
                wantRenderNotification = true;
              }
              break;
            }
          } else {
            if (finishDrawingRunnable != null) {
              Log.w(TAG, "Warning, !readyToDraw() but waiting for " +
                    "draw finished! Early reporting draw finished.");
              finishDrawingRunnable.run();
              finishDrawingRunnable = null;
            }
          }
          // By design, this is the only place in a GLState thread where we wait().
          if (LOG_THREADS) {
            Log.i("GLState", "waiting tid=" + mOwnerThread.getId()
                  + " mHaveEglContext: " + mHaveEglContext
                  + " mHaveEglSurface: " + mHaveEglSurface
                  + " mFinishedCreatingEglSurface: " + mFinishedCreatingEglSurface
                  + " mPaused: " + mPaused
                  + " mHasSurface: " + mHasSurface
                  + " mSurfaceIsBad: " + mSurfaceIsBad
                  + " mWaitingForSurface: " + mWaitingForSurface
                  + " mWidth: " + mWidth
                  + " mHeight: " + mHeight
                  + " mRequestRender: " + mRequestRender
                  + " mRenderMode: " + mRenderMode);
          }
          return; // sGLStateManager.wait();
        }
      }
      // end of synchronized(sGLStateManager)
      if (event != null) {
        // early exited monitor; why?  Run event and retry step
        event.run();  // BEWARE: MUST NOT block on native code.
        event = null;
        continue;
      }
      if (createEglSurface) {
        if (LOG_SURFACE) {
          Log.w("GLState", "egl createSurface");
        }
        if (mEglHelper.createSurface()) {
          synchronized(sGLStateManager) {
            mFinishedCreatingEglSurface = true;
            sGLStateManager.notifyAll();
          }
        } else {
          synchronized(sGLStateManager) {
            mFinishedCreatingEglSurface = true;
            mSurfaceIsBad = true;
            sGLStateManager.notifyAll();
          }
          continue;
        }
        createEglSurface = false;
      }
      if (createGlInterface) {
        gl = (GL10) mEglHelper.createGL();
        createGlInterface = false;
      }
      if (createEglContext) {
        if (LOG_RENDERER) {
          Log.w("GLState", "onSurfaceCreated");
        }
        NativeGLSurfaceView view = mNativeGLSurfaceViewWeakRef.get();
        if (view != null) {
          // try {
          //  Trace.traceBegin(Trace.TRACE_TAG_VIEW, "onSurfaceCreated");
          view.getRenderer().onSurfaceCreated(gl, mEglHelper.mEglConfig);
          // } finally {
          //  Trace.traceEnd(Trace.TRACE_TAG_VIEW);
          // }
        }
        createEglContext = false;
      }
      if (sizeChanged) {
        if (LOG_RENDERER) {
          Log.w("GLState", "onSurfaceChanged(" + w + ", " + h + ")");
        }
        NativeGLSurfaceView view = mNativeGLSurfaceViewWeakRef.get();
        if (view != null) {
          // try {
          //   Trace.traceBegin(Trace.TRACE_TAG_VIEW, "onSurfaceChanged");
          view.getRenderer().onSurfaceChanged(gl, w, h);
          // } finally {
          //   Trace.traceEnd(Trace.TRACE_TAG_VIEW);
          // }
        }
        sizeChanged = false;
      }
      break;
    }
  }
  private void fromNativeOnDrawFrame() throws InterruptedException {
    if (LOG_RENDERER_DRAW_FRAME) {
      Log.w("GLState", "onDrawFrame tid=" + mOwnerThread.getId());
    }
    {
      NativeGLSurfaceView view = mNativeGLSurfaceViewWeakRef.get();
      if (view != null) {
        // try {
        //   Trace.traceBegin(Trace.TRACE_TAG_VIEW, "onDrawFrame");
        view.getRenderer().onDrawFrame(gl);
        if (finishDrawingRunnable != null) {
          finishDrawingRunnable.run();
          finishDrawingRunnable = null;
        }
        // } finally {
        //   Trace.traceEnd(Trace.TRACE_TAG_VIEW);
        // }
      }
    }
  }
  private void fromNativeSwapBuffers() throws InterruptedException {
    if(mEglHelper.mEglDisplay==null) {
      Log.e("GLState", "fromNativeSwapBuffers no display tid=" + mOwnerThread.getId());
      return;
    }
    if(mEglHelper.mEglSurface==null) {
      Log.e("GLState", "fromNativeSwapBuffers no surface tid=" + mOwnerThread.getId());
      return;
    }
    if (finishDrawingRunnable != null) { // fromNativeOnDrawFrame shall be optional
      if (LOG_RENDERER) {
        Log.i("GLState", "fromNativeSwapBuffers running finishDrawingRunnable " + finishDrawingRunnable);
      }
      finishDrawingRunnable.run();
      // Log.i("GLState", "fromNativeSwapBuffers done with finishDrawingRunnable");
      finishDrawingRunnable = null;
    } else {
      if (LOG_RENDERER) {
        Log.i("GLState", "fromNativeSwapBuffers no finishDrawingRunnable given");
      }
    }
    int swapError = mEglHelper.swap();
    switch (swapError) {
    case EGL10.EGL_SUCCESS:
      break;
    case EGL11.EGL_CONTEXT_LOST:
      if (LOG_SURFACE) {
        Log.i("GLState", "egl context lost tid=" + mOwnerThread.getId());
      }
      lostEglContext = true;
      break;
    default:
      // Other errors typically mean that the current surface is bad,
      // probably because the SurfaceView surface has been destroyed,
      // but we haven't been notified yet.
      // Log the error to help developers understand why rendering stopped.
      EglHelper.logEglErrorAsWarning("GLState", "eglSwapBuffers", swapError);
      synchronized(sGLStateManager) {
        mSurfaceIsBad = true;
        sGLStateManager.notifyAll();
      }
      break;
    }
    if (wantRenderNotification) {
      doRenderNotification = true;
      wantRenderNotification = false;
    }
  }
  public boolean ableToDraw() {
    return mHaveEglContext && mHaveEglSurface && readyToDraw();
  }
  private boolean readyToDraw() {
    return (!mPaused) && mHasSurface && (!mSurfaceIsBad)
      && (mWidth > 0) && (mHeight > 0)
      && (mRequestRender || (mRenderMode == NativeGLSurfaceView.RENDERMODE_CONTINUOUSLY));
  }
  public void setRenderMode(int renderMode) {
    if ( !((NativeGLSurfaceView.RENDERMODE_WHEN_DIRTY <= renderMode) && (renderMode <= NativeGLSurfaceView.RENDERMODE_CONTINUOUSLY)) ) {
      throw new IllegalArgumentException("renderMode");
    }
    synchronized(sGLStateManager) {
      mRenderMode = renderMode;
      sGLStateManager.notifyAll();
    }
  }
  public int getRenderMode() {
    synchronized(sGLStateManager) {
      return mRenderMode;
    }
  }
  public void requestRender() {
    // TBD: does not make much sense at all.
    synchronized(sGLStateManager) {
      mRequestRender = true;
      sGLStateManager.notifyAll();
    }
  }
  public void requestRenderAndNotify(Runnable finishDrawing) {
    if(LOG_THREADS) {
      Log.i("GLState", "requestRenderAndNotify tid=" + Thread.currentThread().getName() + " then " + finishDrawing);
    }
    synchronized(sGLStateManager) {
      // If we are already on the GL thread, this means a client callback
      // has caused reentrancy, for example via updating the SurfaceView parameters.
      // We will return to the client rendering code, so here we don't need to
      // do anything.
      if (Thread.currentThread() == mOwnerThread) {
        return;
      }
      mWantRenderNotification = true;
      mRequestRender = true;
      mRenderComplete = false;
      mFinishDrawingRunnable = finishDrawing;
      sGLStateManager.notifyAll();
    }
  }
  public void surfaceCreated() {
    synchronized(sGLStateManager) {
      if (LOG_THREADS) {
        Log.i("GLState", "surfaceCreated tid=" + Thread.currentThread().getName());
      }
      mHasSurface = true;
      mFinishedCreatingEglSurface = false;
      sGLStateManager.notifyAll();
      // while (mWaitingForSurface
      //        && !mFinishedCreatingEglSurface
      //        && !mExited) {
      //   try {
      //     sGLStateManager.wait();
      //   } catch (InterruptedException e) {
      //     Thread.currentThread().interrupt();
      //   }
      // }
    }
    NativeGLSurfaceView view = mNativeGLSurfaceViewWeakRef.get();
    view.getRenderer().onSurfaceCreated(null, null);
  }
  public void surfaceDestroyed() {
    synchronized(sGLStateManager) {
      if (LOG_THREADS) {
        Log.i("GLState", "surfaceDestroyed tid=" + Thread.currentThread().getName());
      }
      mHasSurface = false;
      sGLStateManager.notifyAll();
      // while((!mWaitingForSurface) && (!mExited)) {
      //   try {
      //     sGLStateManager.wait();
      //   } catch (InterruptedException e) {
      //     Thread.currentThread().interrupt();
      //   }
      // }
    }
    NativeGLSurfaceView view = mNativeGLSurfaceViewWeakRef.get();
    view.getRenderer().onPause();
  }
  public void onWindowResize(int w, int h) {
    NativeGLSurfaceView view;
    synchronized (sGLStateManager) {
      mWidth = w;
      mHeight = h;
      mSizeChanged = true;
      mRequestRender = true;
      mRenderComplete = false;
      // If we are already on the GL thread, this means a client callback
      // has caused reentrancy, for example via updating the SurfaceView parameters.
      // We need to process the size change eventually though and update our EGLSurface.
      // So we set the parameters and return so they can be processed on our
      // next iteration.
      if (Thread.currentThread() == mOwnerThread) {
        return;
      }
      if (LOG_SURFACE) {
        Log.i("GLState", "onWindowResize notifying renderer from tid=" +  Thread.currentThread().getName());
      }
      view = mNativeGLSurfaceViewWeakRef.get();
      sGLStateManager.notifyAll();
    }
    // Wait for thread to react to resize and render a frame
    view.getRenderer().onWindowResize(w, h);
  }
  public void requestExitAndWait() {
    // don't call this from GLState thread or it is a guaranteed
    // deadlock!
    synchronized(sGLStateManager) {
      mShouldExit = true;
      sGLStateManager.notifyAll();
      while (! mExited) {
        try {
          sGLStateManager.wait();
        } catch (InterruptedException ex) {
          Thread.currentThread().interrupt();
        }
      }
    }
  }
  public void requestReleaseEglContextLocked() {
    mShouldReleaseEglContext = true;
    sGLStateManager.notifyAll();
  }
  /**
   * Queue an "event" to be run on the GL rendering thread.
   * @param r the runnable to be run on the GL rendering thread.
   */
  public void queueEvent(Runnable r) {
    if (r == null) {
      throw new IllegalArgumentException("r must not be null");
    }
    synchronized(sGLStateManager) {
      mEventQueue.add(r);
      sGLStateManager.notifyAll();
    }
  }
  // Once the thread is started, all accesses to the following member
  // variables are protected by the sGLStateManager monitor
  private boolean mShouldExit;
  private boolean mExited;
  private boolean mRequestPaused;
  private boolean mPaused;
  private boolean mHasSurface;
  private boolean mSurfaceIsBad;
  private boolean mWaitingForSurface;
  private boolean mHaveEglContext;
  private boolean mHaveEglSurface;
  private boolean mFinishedCreatingEglSurface;
  private boolean mShouldReleaseEglContext;
  private int mWidth;
  private int mHeight;
  private int mRenderMode;
  private boolean mRequestRender;
  private boolean mWantRenderNotification;
  private boolean mRenderComplete;
  private ArrayList<Runnable> mEventQueue = new ArrayList<Runnable>();
  private boolean mSizeChanged = true;
  private Runnable mFinishDrawingRunnable = null;
  // End of member variables protected by the sGLStateManager monitor.
  // @UnsupportedAppUsage
  private EglHelper mEglHelper;
  /**
   * Set once at thread construction time, nulled out when the parent view is garbage
   * called. This weak reference allows the NativeGLSurfaceView to be garbage collected while
   * the GLState is still alive.
   */
  private WeakReference<NativeGLSurfaceView> mNativeGLSurfaceViewWeakRef;
    /**
   * An EGL helper class.
   */
  private static class EglHelper {
    public EglHelper(WeakReference<NativeGLSurfaceView> glSurfaceViewWeakRef) {
      mNativeGLSurfaceViewWeakRef = glSurfaceViewWeakRef;
      mEglSurface = null;
    }
    /**
     * Initialize EGL for a given configuration spec.
     * @param configSpec
     */
    public void start() {
      if (LOG_EGL) {
        Log.w("EglHelper", "start() tid=" + Thread.currentThread().getName());
      }
      /*
       * Get an EGL instance
       */
      mEgl = (EGL10) EGLContext.getEGL();
      /*
       * Get to the default display.
       */
      mEglDisplay = mEgl.eglGetDisplay(EGL10.EGL_DEFAULT_DISPLAY);
      if (mEglDisplay == EGL10.EGL_NO_DISPLAY) {
        throw new RuntimeException("eglGetDisplay failed");
      }
      /*
       * We can now initialize EGL for that display
       */
      int[] version = new int[2];
      if(!mEgl.eglInitialize(mEglDisplay, version)) {
        throw new RuntimeException("eglInitialize failed");
      }
      NativeGLSurfaceView view = mNativeGLSurfaceViewWeakRef.get();
      if (view == null) {
        mEglConfig = null;
        mEglContext = null;
      } else {
        mEglConfig = view.getEGLConfigChooser().chooseConfig(mEgl, mEglDisplay);
        /*
         * Create an EGL context. We want to do this as rarely as we can, because an
         * EGL context is a somewhat heavy object.
         */
        mEglContext = view.getEGLContextFactory().createContext(mEgl, mEglDisplay, mEglConfig);
      }
      if (mEglContext == null || mEglContext == EGL10.EGL_NO_CONTEXT) {
        mEglContext = null;
        throwEglException("createContext");
      }
      if (LOG_EGL) {
        Log.w("EglHelper", "createContext " + mEglContext + " tid=" + Thread.currentThread().getName());
      }
    }
    /**
     * Create an egl surface for the current SurfaceHolder surface. If a surface
     * already exists, destroy it before creating the new surface.
     *
     * @return true if the surface was created successfully.
     */
    public boolean createSurface() {
      if (LOG_EGL) {
        Log.w("EglHelper", "createSurface()  tid=" + Thread.currentThread().getName());
      }
      /*
       * Check preconditions.
       */
      if (mEgl == null) {
        throw new RuntimeException("egl not initialized");
      }
      if (mEglDisplay == null) {
        throw new RuntimeException("eglDisplay not initialized");
      }
      if (mEglConfig == null) {
        throw new RuntimeException("mEglConfig not initialized");
      }
      /*
       *  The window size has changed, so we need to create a new
       *  surface.
       */
      destroySurfaceImp();
      /*
       * Create an EGL surface we can render into.
       */
      NativeGLSurfaceView view = mNativeGLSurfaceViewWeakRef.get();
      if (view != null) {
        mEglSurface = view.getEGLWindowSurfaceFactory().createWindowSurface
          (mEgl, mEglDisplay, mEglConfig, view.getHolder());
      } else {
        mEglSurface = null;
      }
      if (mEglSurface == null || mEglSurface == EGL10.EGL_NO_SURFACE) {
        int error = mEgl.eglGetError();
        if (error == EGL10.EGL_BAD_NATIVE_WINDOW) {
          Log.e("EglHelper", "createWindowSurface returned EGL_BAD_NATIVE_WINDOW.");
        }
        return false;
      }
      /*
       * Before we can issue GL commands, we need to make sure
       * the context is current and bound to a surface.
       */
      if (!mEgl.eglMakeCurrent(mEglDisplay, mEglSurface, mEglSurface, mEglContext)) {
        /*
         * Could not make the context current, probably because the underlying
         * SurfaceView surface has been destroyed.
         */
        logEglErrorAsWarning("EGLHelper", "eglMakeCurrent", mEgl.eglGetError());
        return false;
      }
      return true;
    }
    /**
     * Create a GL object for the current EGL context.
     * @return
     */
    GL createGL() {
      GL gl = mEglContext.getGL();
      NativeGLSurfaceView view = mNativeGLSurfaceViewWeakRef.get();
      if (view != null) {
        NativeGLSurfaceView.GLWrapper wrapper = view.getGLWrapper();
        if (wrapper != null) {
          gl = wrapper.wrap(gl);
        }
        int view_mDebugFlags = view.getDebugFlags();
        if ((view_mDebugFlags & (NativeGLSurfaceView.DEBUG_CHECK_GL_ERROR | NativeGLSurfaceView.DEBUG_LOG_GL_CALLS)) != 0) {
          int configFlags = 0;
          Writer log = null;
          if ((view_mDebugFlags & NativeGLSurfaceView.DEBUG_CHECK_GL_ERROR) != 0) {
            configFlags |= GLDebugHelper.CONFIG_CHECK_GL_ERROR;
          }
          if ((view_mDebugFlags & NativeGLSurfaceView.DEBUG_LOG_GL_CALLS) != 0) {
            log = new NativeGLSurfaceView.LogWriter();
          }
          gl = GLDebugHelper.wrap(gl, configFlags, log);
        }
      }
      return gl;
    }
    /**
     * Display the current render surface.
     * @return the EGL error code from eglSwapBuffers.
     */
    public int swap() {
      if (! mEgl.eglSwapBuffers(mEglDisplay, mEglSurface)) {
        return mEgl.eglGetError();
      }
      return EGL10.EGL_SUCCESS;
    }
    public void destroySurface() {
      if (LOG_EGL) {
        Log.w("EglHelper", "destroySurface()  tid=" + Thread.currentThread().getName());
      }
      destroySurfaceImp();
    }
    private void destroySurfaceImp() {
      if (mEglSurface != null && mEglSurface != EGL10.EGL_NO_SURFACE) {
        mEgl.eglMakeCurrent(mEglDisplay, EGL10.EGL_NO_SURFACE,
                            EGL10.EGL_NO_SURFACE,
                            EGL10.EGL_NO_CONTEXT);
        NativeGLSurfaceView view = mNativeGLSurfaceViewWeakRef.get();
        if (view != null) {
          view.getEGLWindowSurfaceFactory().destroySurface(mEgl, mEglDisplay, mEglSurface);
        }
        mEglSurface = null;
      }
    }
    public void finish() {
      if (LOG_EGL) {
        Log.w("EglHelper", "finish() tid=" + Thread.currentThread().getName());
      }
      if (mEglContext != null) {
        NativeGLSurfaceView view = mNativeGLSurfaceViewWeakRef.get();
        if (view != null) {
          view.getEGLContextFactory().destroyContext(mEgl, mEglDisplay, mEglContext);
        }
        mEglContext = null;
      }
      if (mEglDisplay != null) {
        mEgl.eglTerminate(mEglDisplay);
        mEglDisplay = null;
      }
    }
    private void throwEglException(String function) {
      throwEglException(function, mEgl.eglGetError());
    }
    public static void throwEglException(String function, int error) {
      String message = formatEglError(function, error);
      if (LOG_THREADS) {
        Log.e("EglHelper", "throwEglException tid=" + Thread.currentThread().getName() + " "
              + message);
      }
      throw new RuntimeException(message);
    }
    public static void logEglErrorAsWarning(String tag, String function, int error) {
      Log.w(tag, formatEglError(function, error));
    }
    public static String formatEglError(String function, int error) {
      return function + " failed: " + error; // EGLLogWrapper.getErrorString(error);
    }
    private WeakReference<NativeGLSurfaceView> mNativeGLSurfaceViewWeakRef;
    EGL10 mEgl;
    EGLDisplay mEglDisplay;
    EGLSurface mEglSurface;
    EGLConfig mEglConfig;
    // @UnsupportedAppUsage
    EGLContext mEglContext;
  }
  public void throwEglException(String function) {
    if(mEglHelper!=null) {
      mEglHelper.throwEglException(function);
    }
  }
  private static class GLStateManager {
    private static String TAG = "GLStateManager";
    public synchronized void threadExiting(GLState thread) {
      if (LOG_THREADS) {
        Log.i("GLState", "exiting tid=" +  Thread.currentThread().getName());
      }
      thread.mExited = true;
      notifyAll();
    }
    /*
     * Releases the EGL context. Requires that we are already in the
     * sGLStateManager monitor when this is called.
     */
    public void releaseEglContextLocked(GLState thread) {
      notifyAll();
    }
  }
}
