/* NativeGLSurfaceView -*- mode: java; c-basic-offset: 2; -*- */
/*
 * Copyright (C) 2021 JFW
 *
 * # History
 *
 * - API derived from from GLSurfaceView.  Must not create its own
 * rendering thread; it is not safe to call into Gambit from multiple
 * threads unless no threads or asynchronous i/o is done in Gambit.
 *
 * - Stripped down to API, keeping comments mostly for documentation.
 *
 * Copyright (C) 2008 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package @SYS_PACKAGE_DOT@;

// import android.compat.annotation.UnsupportedAppUsage;
import android.content.Context;
import android.os.Trace;
import android.util.AttributeSet;
import android.util.Log;
import android.view.SurfaceHolder;
import android.view.SurfaceView;

import java.io.Writer;
import java.lang.ref.WeakReference;

import javax.microedition.khronos.egl.EGL10;
import javax.microedition.khronos.egl.EGL11;
import javax.microedition.khronos.egl.EGLConfig;
import javax.microedition.khronos.egl.EGLContext;
import javax.microedition.khronos.egl.EGLDisplay;
import javax.microedition.khronos.egl.EGLSurface;
import javax.microedition.khronos.opengles.GL;
import javax.microedition.khronos.opengles.GL10;

import android.opengl.EGLExt;
import android.opengl.EGL14;


/**
 * An implementation of SurfaceView that uses the dedicated surface for
 * displaying OpenGL rendering.
 * <p>
 * A NativeGLSurfaceView provides the following features:
 * <p>
 * <ul>
 * <li>Manages a surface, which is a special piece of memory that can be
 * composited into the Android view system.
 * <li>Manages an EGL display, which enables OpenGL to render into a surface.
 * <li>Accepts a user-provided Renderer object that does the actual rendering.
 * <li>Renders on a native thread decoupled from the UI thread.
 * <li>Supports both on-demand and continuous rendering.
 * <li>Optionally wraps, traces, and/or error-checks the renderer's OpenGL calls.
 * </ul>
 *
 * <div class="special reference">
 * <h3>Developer Guides</h3>
 * <p>For more information about how to use OpenGL, read the
 * <a href="{@docRoot}guide/topics/graphics/opengl.html">OpenGL</a> developer guide.</p>
 * </div>
 *
 * <h3>Using NativeGLSurfaceView</h3>
 * <p>
 * Typically you use NativeGLSurfaceView by subclassing it and overriding one or more of the
 * View system input event methods. If your application does not need to override event
 * methods then NativeGLSurfaceView can be used as-is. For the most part
 * NativeGLSurfaceView behavior is customized by calling "set" methods rather than by subclassing.
 * For example, unlike a regular View, drawing is delegated to a separate Renderer object which
 * is registered with the NativeGLSurfaceView
 * using the {@link #setRenderer(Renderer)} call.
 *
 * NOTE: The above comment derives from GLSurfaceView.  Those set
 * methods are likely to be removed when the code matures.
 *
 * <p>
 * <h3>Initializing NativeGLSurfaceView</h3>
 * All you have to do to initialize a NativeGLSurfaceView is call {@link #setRenderer(Renderer)}.
 * However, if desired, you can modify the default behavior of NativeGLSurfaceView by calling one or
 * more of these methods before calling setRenderer:
 * <ul>
 * <li>{@link #setDebugFlags(int)}
 * <li>{@link #setEGLConfigChooser(boolean)}
 * <li>{@link #setEGLConfigChooser(EGLConfigChooser)}
 * <li>{@link #setEGLConfigChooser(int, int, int, int, int, int)}
 * <li>{@link #setGLWrapper(GLWrapper)}
 * </ul>
 * <p>
 * <h4>Specifying the android.view.Surface</h4>
 * By default NativeGLSurfaceView will create a PixelFormat.RGB_888 format surface. If a translucent
 * surface is required, call getHolder().setFormat(PixelFormat.TRANSLUCENT).
 * The exact format of a TRANSLUCENT surface is device dependent, but it will be
 * a 32-bit-per-pixel surface with 8 bits per component.
 * <p>
 * <h4>Choosing an EGL Configuration</h4>
 * A given Android device may support multiple EGLConfig rendering configurations.
 * The available configurations may differ in how many channels of data are present, as
 * well as how many bits are allocated to each channel. Therefore, the first thing
 * NativeGLSurfaceView has to do when starting to render is choose what EGLConfig to use.
 * <p>
 * By default NativeGLSurfaceView chooses a EGLConfig that has an RGB_888 pixel format,
 * with at least a 16-bit depth buffer and no stencil.
 * <p>
 * If you would prefer a different EGLConfig
 * you can override the default behavior by calling one of the
 * setEGLConfigChooser methods.
 * <p>
 * <h4>Debug Behavior</h4>
 * You can optionally modify the behavior of NativeGLSurfaceView by calling
 * one or more of the debugging methods {@link #setDebugFlags(int)},
 * and {@link #setGLWrapper}. These methods may be called before and/or after setRenderer, but
 * typically they are called before setRenderer so that they take effect immediately.
 * <p>
 * <h4>Setting a Renderer</h4>
 * Finally, you must call {@link #setRenderer} to register a {@link Renderer}.
 * The renderer is
 * responsible for doing the actual OpenGL rendering.
 * <p>
 * <h3>Rendering Mode</h3>
 * Once the renderer is set, you can control whether the renderer draws
 * continuously or on-demand by calling
 * {@link #setRenderMode}. The default is continuous rendering.
 * <p>
 * <h3>Activity Life-cycle</h3>
 * A NativeGLSurfaceView should be notified when to pause and resume
 * rendering. NativeGLSurfaceView clients should call {@link
 * #onPause()} when the activity stops and {@link #onResume()} when
 * the activity starts. These calls are forwarded to the object set
 * via setRenderer to pause and resume the rendering thread, and
 * possibly release and recreate the OpenGL display.
 * <p>
 * <h3>Handling events</h3>
 * <p>
 * To handle an event you will typically subclass NativeGLSurfaceView and override the
 * appropriate method, just as you would with any other View. However, when handling
 * the event, you may need to communicate with the Renderer object
 * that's running in the rendering thread. You can do this using any
 * standard Java cross-thread communication mechanism. In addition,
 * one relatively easy way to communicate with your renderer is
 * to call
 * {@link #queueEvent(Runnable)}. For example:
 * <pre class="prettyprint">
 * class MyNativeGLSurfaceView extends NativeGLSurfaceView {
 *
 *     private MyRenderer mMyRenderer;
 *
 *     public void start() {
 *         mMyRenderer = ...;
 *         setRenderer(mMyRenderer);
 *     }
 *
 *     public boolean onKeyDown(int keyCode, KeyEvent event) {
 *         if (keyCode == KeyEvent.KEYCODE_DPAD_CENTER) {
 *             queueEvent(new Runnable() {
 *                 // This method will be called on the rendering
 *                 // thread:
 *                 public void run() {
 *                     mMyRenderer.handleDpadCenter();
 *                 }});
 *             return true;
 *         }
 *         return super.onKeyDown(keyCode, event);
 *     }
 * }
 * </pre>
 *
 */
public class NativeGLSurfaceView extends SurfaceView implements SurfaceHolder.Callback2 {
  private final static String TAG = "NativeGLSurfaceView";
  private final static boolean LOG_ATTACH_DETACH = false;
  private final static boolean LOG_THREADS = false;

  /* Summary 20210415:
   *
   * private final WeakReference<NativeGLSurfaceView> mThisWeakRef =
   *   new WeakReference<NativeGLSurfaceView>(this);
   * // @UnsupportedAppUsage
   * private GLState mGLState;
   * // @UnsupportedAppUsage
   * private Renderer mRenderer;
   * private boolean mDetached;
   * private EGLConfigChooser mEGLConfigChooser;
   * private EGLContextFactory mEGLContextFactory;
   * private EGLWindowSurfaceFactory mEGLWindowSurfaceFactory;
   * private GLWrapper mGLWrapper;
   * private int mDebugFlags;
   * private int mEGLContextClientVersion;
   * private boolean mPreserveEGLContextOnPause;
   */

  /**
   * The renderer only renders
   * when the surface is created, or when {@link #requestRender} is called.
   *
   * @see #getRenderMode()
   * @see #setRenderMode(int)
   * @see #requestRender()
   */
  public final static int RENDERMODE_WHEN_DIRTY = 0;
  /**
   * The renderer is called
   * continuously to re-render the scene.
   *
   * @see #getRenderMode()
   * @see #setRenderMode(int)
   */
  public final static int RENDERMODE_CONTINUOUSLY = 1;
  /**
   * Check glError() after every GL call and throw an exception if glError indicates
   * that an error has occurred. This can be used to help track down which OpenGL ES call
   * is causing an error.
   *
   * @see #getDebugFlags
   * @see #setDebugFlags
   */
  public final static int DEBUG_CHECK_GL_ERROR = 1;
  /**
   * Log GL calls to the system log at "verbose" level with tag "NativeGLSurfaceView".
   *
   * @see #getDebugFlags
   * @see #setDebugFlags
   */
  public final static int DEBUG_LOG_GL_CALLS = 2;
  /**
   * Standard View constructor. In order to render something, you
   * must call {@link #setRenderer} to register a renderer.
   */
  public NativeGLSurfaceView(Context context) {
    super(context);
    init();
  }
  /**
   * Standard View constructor. In order to render something, you
   * must call {@link #setRenderer} to register a renderer.
   */
  public NativeGLSurfaceView(Context context, AttributeSet attrs) {
    super(context, attrs);
    init();
  }
  private void init() {
    // Install a SurfaceHolder.Callback so we get notified when the
    // underlying surface is created and destroyed
    SurfaceHolder holder = getHolder();
    holder.addCallback(this);
    // setFormat is done by SurfaceView in SDK 2.3 and newer. Uncomment
    // this statement if back-porting to 2.2 or older:
    // holder.setFormat(PixelFormat.RGB_565);
    //
    // setType is not needed for SDK 2.0 or newer. Uncomment this
    // statement if back-porting this code to older SDKs.
    // holder.setType(SurfaceHolder.SURFACE_TYPE_GPU);
  }
  /**
   * Set the glWrapper. If the glWrapper is not null, its
   * {@link GLWrapper#wrap(GL)} method is called
   * whenever a surface is created. A GLWrapper can be used to wrap
   * the GL object that's passed to the renderer. Wrapping a GL
   * object enables examining and modifying the behavior of the
   * GL calls made by the renderer.
   * <p>
   * Wrapping is typically used for debugging purposes.
   * <p>
   * The default value is null.
   * @param glWrapper the new GLWrapper
   */
  private GLWrapper mGLWrapper;
  public GLWrapper getGLWrapper() { return mGLWrapper; }
  public void setGLWrapper(GLWrapper glWrapper) {
    mGLWrapper = glWrapper;
  }
  /**
   * Set the debug flags to a new value. The value is
   * constructed by OR-together zero or more
   * of the DEBUG_CHECK_* constants. The debug flags take effect
   * whenever a surface is created. The default value is zero.
   * @param debugFlags the new debug flags
   * @see #DEBUG_CHECK_GL_ERROR
   * @see #DEBUG_LOG_GL_CALLS
   */
  private int mDebugFlags;
  public void setDebugFlags(int debugFlags) {
    mDebugFlags = debugFlags;
  }
  /**
   * Get the current value of the debug flags.
   * @return the current value of the debug flags.
   */
  public int getDebugFlags() {
    return mDebugFlags;
  }
  /**
   * Control whether the EGL context is preserved when the NativeGLSurfaceView is paused and
   * resumed.
   * <p>
   * If set to true, then the EGL context may be preserved when the NativeGLSurfaceView is paused.
   * <p>
   * Prior to API level 11, whether the EGL context is actually preserved or not
   * depends upon whether the Android device can support an arbitrary number of
   * EGL contexts or not. Devices that can only support a limited number of EGL
   * contexts must release the EGL context in order to allow multiple applications
   * to share the GPU.
   * <p>
   * If set to false, the EGL context will be released when the NativeGLSurfaceView is paused,
   * and recreated when the NativeGLSurfaceView is resumed.
   * <p>
   *
   * The default is false.
   *
   * @param preserveOnPause preserve the EGL context when paused
   */
  private boolean mPreserveEGLContextOnPause;
  public void setPreserveEGLContextOnPause(boolean preserveOnPause) {
    mPreserveEGLContextOnPause = preserveOnPause;
  }
  /**
   * @return true if the EGL context will be preserved when paused
   */
  public boolean getPreserveEGLContextOnPause() {
    return mPreserveEGLContextOnPause;
  }
  /**
   * Set the renderer associated with this view. Also starts the thread that
   * will call the renderer, which in turn causes the rendering to start.
   * <p>This method should be called once and only once in the life-cycle of
   * a NativeGLSurfaceView.
   * <p>The following NativeGLSurfaceView methods can only be called <em>before</em>
   * setRenderer is called:
   * <ul>
   * <li>{@link #setEGLConfigChooser(boolean)}
   * <li>{@link #setEGLConfigChooser(EGLConfigChooser)}
   * <li>{@link #setEGLConfigChooser(int, int, int, int, int, int)}
   * </ul>
   * <p>
   * The following NativeGLSurfaceView methods can only be called <em>after</em>
   * setRenderer is called:
   * <ul>
   * <li>{@link #getRenderMode()}
   * <li>{@link #onPause()}
   * <li>{@link #onResume()}
   * <li>{@link #queueEvent(Runnable)}
   * <li>{@link #requestRender()}
   * <li>{@link #setRenderMode(int)}
   * </ul>
   *
   * @param renderer the renderer to use to perform OpenGL drawing.
   */
  private EGLConfigChooser mEGLConfigChooser;
  public EGLConfigChooser getEGLConfigChooser() { return mEGLConfigChooser; }
  private EGLContextFactory mEGLContextFactory;
  public EGLContextFactory getEGLContextFactory() { return mEGLContextFactory; }
  private EGLWindowSurfaceFactory mEGLWindowSurfaceFactory;
  public EGLWindowSurfaceFactory getEGLWindowSurfaceFactory() { return mEGLWindowSurfaceFactory; }
  // @UnsupportedAppUsage
  private Renderer mRenderer;
  // @UnsupportedAppUsage
  private final WeakReference<NativeGLSurfaceView> mThisWeakRef =
    new WeakReference<NativeGLSurfaceView>(this);
  public void setRenderer(Renderer renderer) {
    checkRenderThreadState();
    if (mEGLConfigChooser == null) {
      mEGLConfigChooser = new SimpleEGLConfigChooser(true);
    }
    if (mEGLContextFactory == null) {
      mEGLContextFactory = new DefaultContextFactory(); // FIXME: depends on mEGLContextClientVersion
    }
    if (mEGLWindowSurfaceFactory == null) {
      mEGLWindowSurfaceFactory = new DefaultWindowSurfaceFactory();
    }
    mRenderer = renderer;
    mGLState = new GLState(mThisWeakRef);
    mRenderer.start();
  }
  public Renderer getRenderer() { return mRenderer; }
  /**
   * Install a custom EGLContextFactory.
   * <p>If this method is
   * called, it must be called before {@link #setRenderer(Renderer)}
   * is called.
   * <p>
   * If this method is not called, then by default
   * a context will be created with no shared context and
   * with a null attribute list.
   */
  public void setEGLContextFactory(EGLContextFactory factory) {
    checkRenderThreadState();
    mEGLContextFactory = factory;
  }
  /**
   * Install a custom EGLWindowSurfaceFactory.
   * <p>If this method is
   * called, it must be called before {@link #setRenderer(Renderer)}
   * is called.
   * <p>
   * If this method is not called, then by default
   * a window surface will be created with a null attribute list.
   */
  public void setEGLWindowSurfaceFactory(EGLWindowSurfaceFactory factory) {
    checkRenderThreadState();
    mEGLWindowSurfaceFactory = factory;
  }
  /**
   * Install a custom EGLConfigChooser.
   * <p>If this method is
   * called, it must be called before {@link #setRenderer(Renderer)}
   * is called.
   * <p>
   * If no setEGLConfigChooser method is called, then by default the
   * view will choose an EGLConfig that is compatible with the current
   * android.view.Surface, with a depth buffer depth of
   * at least 16 bits.
   * @param configChooser
   */
  public void setEGLConfigChooser(EGLConfigChooser configChooser) {
    checkRenderThreadState();
    mEGLConfigChooser = configChooser;
  }
  /**
   * Install a config chooser which will choose a config
   * as close to 16-bit RGB as possible, with or without an optional depth
   * buffer as close to 16-bits as possible.
   * <p>If this method is
   * called, it must be called before {@link #setRenderer(Renderer)}
   * is called.
   * <p>
   * If no setEGLConfigChooser method is called, then by default the
   * view will choose an RGB_888 surface with a depth buffer depth of
   * at least 16 bits.
   *
   * @param needDepth
   */
  public void setEGLConfigChooser(boolean needDepth) {
    setEGLConfigChooser(new SimpleEGLConfigChooser(needDepth));
  }
  /**
   * Install a config chooser which will choose a config
   * with at least the specified depthSize and stencilSize,
   * and exactly the specified redSize, greenSize, blueSize and alphaSize.
   * <p>If this method is
   * called, it must be called before {@link #setRenderer(Renderer)}
   * is called.
   * <p>
   * If no setEGLConfigChooser method is called, then by default the
   * view will choose an RGB_888 surface with a depth buffer depth of
   * at least 16 bits.
   *
   */
  public void setEGLConfigChooser(int redSize, int greenSize, int blueSize,
                                  int alphaSize, int depthSize, int stencilSize) {
    setEGLConfigChooser(new ComponentSizeChooser(redSize, greenSize,
                                                 blueSize, alphaSize, depthSize, stencilSize));
  }
  /**
   * Inform the default EGLContextFactory and default EGLConfigChooser
   * which EGLContext client version to pick.
   * <p>Use this method to create an OpenGL ES 2.0-compatible context.
   * Example:
   * <pre class="prettyprint">
   *     public MyView(Context context) {
   *         super(context);
   *         setEGLContextClientVersion(2); // Pick an OpenGL ES 2.0 context.
   *         setRenderer(new MyRenderer());
   *     }
   * </pre>
   * <p>Note: Activities which require OpenGL ES 2.0 should indicate this by
   * setting @lt;uses-feature android:glEsVersion="0x00020000" /> in the activity's
   * AndroidManifest.xml file.
   * <p>If this method is called, it must be called before {@link #setRenderer(Renderer)}
   * is called.
   * <p>This method only affects the behavior of the default EGLContexFactory and the
   * default EGLConfigChooser. If
   * {@link #setEGLContextFactory(EGLContextFactory)} has been called, then the supplied
   * EGLContextFactory is responsible for creating an OpenGL ES 2.0-compatible context.
   * If
   * {@link #setEGLConfigChooser(EGLConfigChooser)} has been called, then the supplied
   * EGLConfigChooser is responsible for choosing an OpenGL ES 2.0-compatible config.
   * @param version The EGLContext client version to choose. Use 2 for OpenGL ES 2.0
   */
  private int mEGLContextClientVersion;
  public void setEGLContextClientVersion(int version) {
    checkRenderThreadState();
    mEGLContextClientVersion = version;
  }
  /**
   * Set the rendering mode. When renderMode is
   * RENDERMODE_CONTINUOUSLY, the renderer is called
   * repeatedly to re-render the scene. When renderMode
   * is RENDERMODE_WHEN_DIRTY, the renderer only rendered when the surface
   * is created, or when {@link #requestRender} is called. Defaults to RENDERMODE_CONTINUOUSLY.
   * <p>
   * Using RENDERMODE_WHEN_DIRTY can improve battery life and overall system performance
   * by allowing the GPU and CPU to idle when the view does not need to be updated.
   * <p>
   * This method can only be called after {@link #setRenderer(Renderer)}
   *
   * @param renderMode one of the RENDERMODE_X constants
   * @see #RENDERMODE_CONTINUOUSLY
   * @see #RENDERMODE_WHEN_DIRTY
   */
  public void setRenderMode(int renderMode) {
    mGLState.setRenderMode(renderMode);
  }
  /**
   * Get the current rendering mode. May be called
   * from any thread. Must not be called before a renderer has been set.
   * @return the current rendering mode.
   * @see #RENDERMODE_CONTINUOUSLY
   * @see #RENDERMODE_WHEN_DIRTY
   */
  public int getRenderMode() {
    return mGLState.getRenderMode();
  }
  /**
   * Request that the renderer render a frame.
   * This method is typically used when the render mode has been set to
   * {@link #RENDERMODE_WHEN_DIRTY}, so that frames are only rendered on demand.
   * May be called
   * from any thread. Must not be called before a renderer has been set.
   */
  public void requestRender() {
    mGLState.requestRender();
  }
  /**
   * This method is part of the SurfaceHolder.Callback interface, and is
   * not normally called or subclassed by clients of NativeGLSurfaceView.
   */
  public void surfaceCreated(SurfaceHolder holder) {
    mGLState.surfaceCreated();
  }
  /**
   * This method is part of the SurfaceHolder.Callback interface, and is
   * not normally called or subclassed by clients of NativeGLSurfaceView.
   */
  public void surfaceDestroyed(SurfaceHolder holder) {
    // Surface will be destroyed when we return
    mGLState.surfaceDestroyed();
  }
  /**
   * This method is part of the SurfaceHolder.Callback interface, and is
   * not normally called or subclassed by clients of NativeGLSurfaceView.
   */
  public void surfaceChanged(SurfaceHolder holder, int format, int w, int h) {
    mGLState.onWindowResize(w, h);
  }
  /**
   * This method is part of the SurfaceHolder.Callback2 interface, and is
   * not normally called or subclassed by clients of NativeGLSurfaceView.
   */
  @Override
  public void surfaceRedrawNeededAsync(SurfaceHolder holder, Runnable finishDrawing) {
    if (mGLState != null) {
      mGLState.requestRenderAndNotify(finishDrawing);
      surfaceRedrawNeeded(holder);
    }
  }
  /**
   * This method is part of the SurfaceHolder.Callback2 interface, and is
   * not normally called or subclassed by clients of NativeGLSurfaceView.
   */
  @Deprecated
  @Override
  public void surfaceRedrawNeeded(SurfaceHolder holder) {
    // Since we are not part of the framework we pretent not to know
    // only surfaceRedrawNeededAsync will be called.
    mRenderer.onRedrawNeeded();
  }
  /**
   * Pause the rendering thread.
   *
   * This method should be called when it is no longer desirable for the
   * NativeGLSurfaceView to continue rendering, such as in response to
   * {@link android.app.Activity#onStop Activity.onStop}.
   *
   * Must not be called before a renderer has been set.
   */
  public void onPause() {
    mRenderer.onPause();
  }
  /**
   * Resumes the rendering thread, re-creating the OpenGL context if necessary. It
   * is the counterpart to {@link #onPause()}.
   *
   * This method should typically be called in
   * {@link android.app.Activity#onStart Activity.onStart}.
   *
   * Must not be called before a renderer has been set.
   */
  public void onResume() {
    mRenderer.onResume();
  }
  /**
   * Queue a runnable to be run on the GL rendering thread. This can be used
   * to communicate with the Renderer on the rendering thread.
   * Must not be called before a renderer has been set.
   * @param r the runnable to be run on the GL rendering thread.
   */
  public void queueEvent(Runnable r) {
    mGLState.queueEvent(r);
  }
  // ----------------------------------------------------------------------
  /**
   * An interface used to wrap a GL interface.
   * <p>Typically
   * used for implementing debugging and tracing on top of the default
   * GL interface. You would typically use this by creating your own class
   * that implemented all the GL methods by delegating to another GL instance.
   * Then you could add your own behavior before or after calling the
   * delegate. All the GLWrapper would do was instantiate and return the
   * wrapper GL instance:
   * <pre class="prettyprint">
   * class MyGLWrapper implements GLWrapper {
   *     GL wrap(GL gl) {
   *         return new MyGLImplementation(gl);
   *     }
   *     static class MyGLImplementation implements GL,GL10,GL11,... {
   *         ...
   *     }
   * }
   * </pre>
   * @see #setGLWrapper(GLWrapper)
   */
  public interface GLWrapper {
    /**
     * Wraps a gl interface in another gl interface.
     * @param gl a GL interface that is to be wrapped.
     * @return either the input argument or another GL object that wraps the input argument.
     */
    GL wrap(GL gl);
  }
  /**
   * A generic renderer interface.
   * <p>
   * The renderer is responsible for making OpenGL calls to render a frame.
   * <p>
   * NativeGLSurfaceView clients typically create their own classes that implement
   * this interface, and then call {@link NativeGLSurfaceView#setRenderer} to
   * register the renderer with the NativeGLSurfaceView.
   * <p>
   *
   * <div class="special reference">
   * <h3>Developer Guides</h3>
   * <p>For more information about how to use OpenGL, read the
   * <a href="{@docRoot}guide/topics/graphics/opengl.html">OpenGL</a> developer guide.</p>
   * </div>
   *
   * <h3>Threading</h3>
   *
   * The renderer will be called on the native thread. Communication
   * to the renderer thread, e.g., from the UI thread, should be done
   * {@link NativeGLSurfaceView#queueEvent(Runnable)}
   *
   * <h3>EGL Context Lost</h3>
   * There are situations where the EGL rendering context will be lost. This
   * typically happens when device wakes up after going to sleep. When
   * the EGL context is lost, all OpenGL resources (such as textures) that are
   * associated with that context will be automatically deleted. In order to
   * keep rendering correctly, a renderer must recreate any lost resources
   * that it still needs. The {@link #onSurfaceCreated(GL10, EGLConfig)} method
   * is a convenient place to do this.
   *
   * @see #setRenderer(Renderer)
   */
  public interface Renderer {
    /* void start()
     *
     * Called when the GLState onject is created.  The native thread
     * must attach by calling GLState.fromNativeStart(); before this
     * call may return.
     */
    void start();
    /* void onPause
     *
     * Called when the NativeGLSurfaceView received an onPause() call.
     */
    void onPause();
    /* void onResume
     *
     * Called when the NativeGLSurfaceView received an onResume() call.
     */
    void onResume();
    /* void onWindowResize(int w, int h)
     *
     * Called when native thread should learn about new dimension.
     */
    void onWindowResize(int w, int h);
    /**
     * Called when the surface is created or recreated.
     * <p>
     * Called when the rendering thread
     * starts and whenever the EGL context is lost. The EGL context will typically
     * be lost when the Android device awakes after going to sleep.
     * <p>
     * Since this method is called at the beginning of rendering, as well as
     * every time the EGL context is lost, this method is a convenient place to put
     * code to create resources that need to be created when the rendering
     * starts, and that need to be recreated when the EGL context is lost.
     * Textures are an example of a resource that you might want to create
     * here.
     * <p>
     * Note that when the EGL context is lost, all OpenGL resources associated
     * with that context will be automatically deleted. You do not need to call
     * the corresponding "glDelete" methods such as glDeleteTextures to
     * manually delete these lost resources.
     * <p>
     * @param gl the GL interface. Use <code>instanceof</code> to
     * test if the interface supports GL11 or higher interfaces.
     * @param config the EGLConfig of the created surface. Can be used
     * to create matching pbuffers.
     */
    void onSurfaceCreated(GL10 gl, EGLConfig config);
    /**
     * Called when the surface changed size.
     * <p>
     * Called after the surface is created and whenever
     * the OpenGL ES surface size changes.
     * <p>
     * Typically you will set your viewport here. If your camera
     * is fixed then you could also set your projection matrix here:
     * <pre class="prettyprint">
     * void onSurfaceChanged(GL10 gl, int width, int height) {
     *     gl.glViewport(0, 0, width, height);
     *     // for a fixed camera, set the projection too
     *     float ratio = (float) width / height;
     *     gl.glMatrixMode(GL10.GL_PROJECTION);
     *     gl.glLoadIdentity();
     *     gl.glFrustumf(-ratio, ratio, -1, 1, 1, 10);
     * }
     * </pre>
     * @param gl the GL interface. Use <code>instanceof</code> to
     * test if the interface supports GL11 or higher interfaces.
     * @param width
     * @param height
     */
    void onSurfaceChanged(GL10 gl, int width, int height);
    /** void onRedrawNeeded()
     *
     * Called to request a redraw of the current frame.
     */
    void onRedrawNeeded();
    /**
     * Optional: Called when the current frame was drawn from native
     * thread just before swapping buffers.
     * <p>
     * This method is responsible for drawing the current frame.
     * <p>
     * The implementation of this method typically looks like this:
     * <pre class="prettyprint">
     * void onDrawFrame(GL10 gl) {
     *     gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
     *     //... other gl calls to render the scene ...
     * }
     * </pre>
     * @param gl the GL interface. Use <code>instanceof</code> to
     * test if the interface supports GL11 or higher interfaces.
     */
    void onDrawFrame(GL10 gl);
  }
  /* NOTE, FIXME: Are these interfaces useful enough to be kept at all? */
  /**
   * An interface for customizing the eglCreateContext and eglDestroyContext calls.
   * <p>
   * This interface must be implemented by clients wishing to call
   * {@link NativeGLSurfaceView#setEGLContextFactory(EGLContextFactory)}
   */
  public interface EGLContextFactory {
    EGLContext createContext(EGL10 egl, EGLDisplay display, EGLConfig eglConfig);
    void destroyContext(EGL10 egl, EGLDisplay display, EGLContext context);
  }
  /**
   * An interface for customizing the eglCreateWindowSurface and eglDestroySurface calls.
   * <p>
   * This interface must be implemented by clients wishing to call
   * {@link NativeGLSurfaceView#setEGLWindowSurfaceFactory(EGLWindowSurfaceFactory)}
   */
  public interface EGLWindowSurfaceFactory {
    /**
     *  @return null if the surface cannot be constructed.
     */
    EGLSurface createWindowSurface(EGL10 egl, EGLDisplay display, EGLConfig config,
                                   Object nativeWindow);
    void destroySurface(EGL10 egl, EGLDisplay display, EGLSurface surface);
  }
  /**
   * An interface for choosing an EGLConfig configuration from a list of
   * potential configurations.
   * <p>
   * This interface must be implemented by clients wishing to call
   * {@link NativeGLSurfaceView#setEGLConfigChooser(EGLConfigChooser)}
   */
  public interface EGLConfigChooser {
    /**
     * Choose a configuration from the list. Implementors typically
     * implement this method by calling
     * {@link EGL10#eglChooseConfig} and iterating through the results. Please consult the
     * EGL specification available from The Khronos Group to learn how to call eglChooseConfig.
     * @param egl the EGL10 for the current display.
     * @param display the current display.
     * @return the chosen configuration.
     */
    EGLConfig chooseConfig(EGL10 egl, EGLDisplay display);
  }
  /*
   *
   * ----------------------- END OF PUBLIC API ------------------------------------------
   *
   */
  /*
   *
   * ----------------------- BEGIN PROTECTED   ------------------------------------------
   *
   */
  // @UnsupportedAppUsage
  private static GLState mGLState; // PRIVATE data referenced from protected code
  @Override
  protected void finalize() throws Throwable {
    try {
      if (mGLState != null) {
        // GLState may still be running if this view was never
        // attached to a window.
        mGLState.requestExitAndWait();
      }
    } finally {
      super.finalize();
    }
  }
  /**
   * This method is used as part of the View class and is not normally
   * called or subclassed by clients of NativeGLSurfaceView.
   */
  private boolean mDetached;
  @Override
  protected void onAttachedToWindow() {
    super.onAttachedToWindow();
    if (LOG_ATTACH_DETACH) {
      Log.d(TAG, "onAttachedToWindow reattach =" + mDetached);
    }
    if (mDetached && (mRenderer != null)) {
      int renderMode = RENDERMODE_CONTINUOUSLY;
      if (mGLState != null) {
        renderMode = mGLState.getRenderMode();
      }
      mGLState = new GLState(mThisWeakRef);
      if (renderMode != RENDERMODE_CONTINUOUSLY) {
        mGLState.setRenderMode(renderMode);
      }
      mRenderer.start();
    }
    mDetached = false;
  }
  @Override
  protected void onDetachedFromWindow() {
    if (LOG_ATTACH_DETACH) {
      Log.d(TAG, "onDetachedFromWindow");
    }
    if (mGLState != null) {
      mGLState.requestExitAndWait();
    }
    mDetached = true;
    super.onDetachedFromWindow();
  }
  private class DefaultContextFactory implements EGLContextFactory {
    private int EGL_CONTEXT_CLIENT_VERSION = 0x3098;
    public EGLContext createContext(EGL10 egl, EGLDisplay display, EGLConfig config) {
      int[] attrib_list = {EGL_CONTEXT_CLIENT_VERSION, mEGLContextClientVersion,
                           EGL10.EGL_NONE };
      return egl.eglCreateContext(display, config, EGL10.EGL_NO_CONTEXT,
                                  mEGLContextClientVersion != 0 ? attrib_list : null);
    }
    public void destroyContext(EGL10 egl, EGLDisplay display,
                               EGLContext context) {
      if (!egl.eglDestroyContext(display, context)) {
        Log.e("DefaultContextFactory", "display:" + display + " context: " + context);
        if (LOG_THREADS) {
          Log.i("DefaultContextFactory", "tid=" + Thread.currentThread().getId());
        }
        mGLState.throwEglException("eglDestroyContex");
      }
    }
  }
  /*
   *
   * ----------------------- END PROTECTED   ------------------------------------------
   *
   */
  /*
   *
   * ----------------------- BEGIN INTERNAL   ------------------------------------------
   *
   */
  private static class DefaultWindowSurfaceFactory implements EGLWindowSurfaceFactory {
    public EGLSurface createWindowSurface(EGL10 egl, EGLDisplay display,
                                          EGLConfig config, Object nativeWindow) {
      EGLSurface result = null;
      try {
        result = egl.eglCreateWindowSurface(display, config, nativeWindow, null);
      } catch (IllegalArgumentException e) {
        // This exception indicates that the surface flinger surface
        // is not valid. This can happen if the surface flinger surface has
        // been torn down, but the application has not yet been
        // notified via SurfaceHolder.Callback.surfaceDestroyed.
        // In theory the application should be notified first,
        // but in practice sometimes it is not. See b/4588890
        Log.e(TAG, "eglCreateWindowSurface", e);
      }
      return result;
    }
    public void destroySurface(EGL10 egl, EGLDisplay display,
                               EGLSurface surface) {
      egl.eglDestroySurface(display, surface);
    }
  }
  private abstract class BaseConfigChooser
    implements EGLConfigChooser {
    public BaseConfigChooser(int[] configSpec) {
      mConfigSpec = filterConfigSpec(configSpec);
    }
    public EGLConfig chooseConfig(EGL10 egl, EGLDisplay display) {
      int[] num_config = new int[1];
      if (!egl.eglChooseConfig(display, mConfigSpec, null, 0,
                               num_config)) {
        throw new IllegalArgumentException("eglChooseConfig failed");
      }
      int numConfigs = num_config[0];
      if (numConfigs <= 0) {
        throw new IllegalArgumentException(
                                           "No configs match configSpec");
      }
      EGLConfig[] configs = new EGLConfig[numConfigs];
      if (!egl.eglChooseConfig(display, mConfigSpec, configs, numConfigs,
                               num_config)) {
        throw new IllegalArgumentException("eglChooseConfig#2 failed");
      }
      EGLConfig config = chooseConfig(egl, display, configs);
      if (config == null) {
        throw new IllegalArgumentException("No config chosen");
      }
      return config;
    }
    abstract EGLConfig chooseConfig(EGL10 egl, EGLDisplay display,
                                    EGLConfig[] configs);
    protected int[] mConfigSpec;
    private int[] filterConfigSpec(int[] configSpec) {
      if (mEGLContextClientVersion != 2 && mEGLContextClientVersion != 3) {
        return configSpec;
      }
      /* We know none of the subclasses define EGL_RENDERABLE_TYPE.
       * And we know the configSpec is well formed.
       */
      int len = configSpec.length;
      int[] newConfigSpec = new int[len + 2];
      System.arraycopy(configSpec, 0, newConfigSpec, 0, len-1);
      newConfigSpec[len-1] = EGL10.EGL_RENDERABLE_TYPE;
      if (mEGLContextClientVersion == 2) {
        newConfigSpec[len] = EGL14.EGL_OPENGL_ES2_BIT;  /* EGL_OPENGL_ES2_BIT */
      } else {
        newConfigSpec[len] = EGLExt.EGL_OPENGL_ES3_BIT_KHR; /* EGL_OPENGL_ES3_BIT_KHR */
      }
      newConfigSpec[len+1] = EGL10.EGL_NONE;
      return newConfigSpec;
    }
  }
  /**
   * Choose a configuration with exactly the specified r,g,b,a sizes,
   * and at least the specified depth and stencil sizes.
   */
  private class ComponentSizeChooser extends BaseConfigChooser {
    public ComponentSizeChooser(int redSize, int greenSize, int blueSize,
                                int alphaSize, int depthSize, int stencilSize) {
      super(new int[] {
          EGL10.EGL_RED_SIZE, redSize,
          EGL10.EGL_GREEN_SIZE, greenSize,
          EGL10.EGL_BLUE_SIZE, blueSize,
          EGL10.EGL_ALPHA_SIZE, alphaSize,
          EGL10.EGL_DEPTH_SIZE, depthSize,
          EGL10.EGL_STENCIL_SIZE, stencilSize,
          EGL10.EGL_NONE});
      mValue = new int[1];
      mRedSize = redSize;
      mGreenSize = greenSize;
      mBlueSize = blueSize;
      mAlphaSize = alphaSize;
      mDepthSize = depthSize;
      mStencilSize = stencilSize;
    }
    @Override
    public EGLConfig chooseConfig(EGL10 egl, EGLDisplay display,
                                  EGLConfig[] configs) {
      for (EGLConfig config : configs) {
        int d = findConfigAttrib(egl, display, config,
                                 EGL10.EGL_DEPTH_SIZE, 0);
        int s = findConfigAttrib(egl, display, config,
                                 EGL10.EGL_STENCIL_SIZE, 0);
        if ((d >= mDepthSize) && (s >= mStencilSize)) {
          int r = findConfigAttrib(egl, display, config,
                                   EGL10.EGL_RED_SIZE, 0);
          int g = findConfigAttrib(egl, display, config,
                                   EGL10.EGL_GREEN_SIZE, 0);
          int b = findConfigAttrib(egl, display, config,
                                   EGL10.EGL_BLUE_SIZE, 0);
          int a = findConfigAttrib(egl, display, config,
                                   EGL10.EGL_ALPHA_SIZE, 0);
          if ((r == mRedSize) && (g == mGreenSize)
              && (b == mBlueSize) && (a == mAlphaSize)) {
            return config;
          }
        }
      }
      return null;
    }
    private int findConfigAttrib(EGL10 egl, EGLDisplay display,
                                 EGLConfig config, int attribute, int defaultValue) {
      if (egl.eglGetConfigAttrib(display, config, attribute, mValue)) {
        return mValue[0];
      }
      return defaultValue;
    }
    private int[] mValue;
    // Subclasses can adjust these values:
    protected int mRedSize;
    protected int mGreenSize;
    protected int mBlueSize;
    protected int mAlphaSize;
    protected int mDepthSize;
    protected int mStencilSize;
  }
  /**
   * This class will choose a RGB_888 surface with
   * or without a depth buffer.
   *
   */
  private class SimpleEGLConfigChooser extends ComponentSizeChooser {
    public SimpleEGLConfigChooser(boolean withDepthBuffer) {
      super(8, 8, 8, 0, withDepthBuffer ? 16 : 0, 0);
    }
  }
  static class LogWriter extends Writer {
    @Override public void close() {
      flushBuilder();
    }
    @Override public void flush() {
      flushBuilder();
    }
    @Override public void write(char[] buf, int offset, int count) {
      for(int i = 0; i < count; i++) {
        char c = buf[offset + i];
        if ( c == '\n') {
          flushBuilder();
        }
        else {
          mBuilder.append(c);
        }
      }
    }
    private void flushBuilder() {
      if (mBuilder.length() > 0) {
        Log.v("NativeGLSurfaceView", mBuilder.toString());
        mBuilder.delete(0, mBuilder.length());
      }
    }
    private StringBuilder mBuilder = new StringBuilder();
  }
  private void checkRenderThreadState() {
    if (mGLState != null) {
      throw new IllegalStateException(
                                      "setRenderer has already been called for this instance.");
    }
  }
}
