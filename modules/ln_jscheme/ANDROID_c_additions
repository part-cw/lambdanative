/* ln_jscheme -*-C-*- */

#if DEBUG
#define LOGJSC(...) ((void)__android_log_print(ANDROID_LOG_ERROR, "@SYS_PACKAGE_UNDERSCORE@_@SYS_APPNAME@_jScheme", __VA_ARGS__))
#else
#define LOGJSC(...)
#endif

// No idea whether ot not global references are required when the
// called site switiches threads.  For flexibility both ways are
// encoded here. (TBD: complete)
#define LNJSCHEME_PASS_INPUT_AS_GLOBAL_REF 1

const char* android_app_class() { return "@SYS_PACKAGE_DOT@.@SYS_APPNAME@"; } // for jscheme

/* lnjscheme_eval
 *
 * Evaluate input and return result.  Due to Android limitations
 * wrt. thread and evaluation context, calls might fail.  E.g., Views
 * may only be changed by the Java thread which created them.  Use the
 * asynchronous version in those cases.
 */
const char* lnjscheme_eval(const char* input)
{
  static const char *str = NULL;
  static jstring jstr = NULL;
  static jmethodID method = 0;
  JNIEnv *env = GetJNIEnv();
  LOGJSC("eval enter env: %p app: %p", env, globalObj);
  if (env&&globalObj){
    jstring jin = (*env)->NewStringUTF(env,input);
    // NOW cached global jclass main_class = (*env)->FindClass(env, "@SYS_PACKAGE_SLASH@/@SYS_APPNAME@");
    if(method==0) {
      method = (*env)->GetMethodID(env, main_class, "LNjSchemeCall", "(Ljava/lang/String;)Ljava/lang/String;");
      if(!method) {
        LOGJSC("ERROR no LNjSchemeCall");
        JNI_forward_exception_to_gambit(env);
        return "E \"JNI: method LNjSchemeCall not found\"";
      }
    }
    /* if(main_class) (*env)->DeleteLocalRef(env, main_class); */
    if(jstr) { (*env)->ReleaseStringUTFChars(env, jstr, str); jstr = NULL; }
    jstr = (jstring) (*env)->CallObjectMethod(env, globalObj, method, jin);
    /*
    (*env)->DeleteLocalRef(env, method);
    (*env)->DeleteLocalRef(env, jin);
    */
    str  = jstr ? (*env)->GetStringUTFChars(env, jstr, 0) : NULL;
    // (*env)->ReleaseStringUTFChars(env, jstr, str);  // we do it upon next call
    JNI_forward_exception_to_gambit(env);
  }
  return str;
}

void lnjscheme_eval_send(const char* input)
{
  JNIEnv *env = GetJNIEnv();
  static jmethodID method = 0;
  if (env) {
#ifdef DEBUG
    if(!globalObj) (*env)->FatalError(env, "@SYS_PACKAGE_UNDERSCORE@ lnjscheme_eval_send no global object!");
#endif
    if(!method) {
      method = (*env)->GetMethodID(env, main_class, "LNjSchemeSend", "(Ljava/lang/String;)V");
      if(!method) {
        LOGE("lnjscheme_eval_send LNjSchemeSend not found; main_class: %p", main_class);
        JNI_forward_exception_to_gambit(env);
        return; // "E \"JNI: method LNjSchemeSend not found\"";
      }
    }
    jstring jin = (*env)->NewStringUTF(env, input);
#if LNJSCHEME_PASS_INPUT_AS_GLOBAL_REF
    jin = (*env)->NewGlobalRef(env, jin);
#endif
    (*env)->CallVoidMethod(env, globalObj, method, jin);
#if LNJSCHEME_PASS_INPUT_AS_GLOBAL_REF
    (*env)->DeleteGlobalRef(env, jin);
#endif
    /*
      (*env)->DeleteLocalRef(env, method);
      (*env)->DeleteLocalRef(env, jin);
    */
    JNI_forward_exception_to_gambit(env);
  }
}

// There is likely a way to do this better using only a Java->C call
// to deposit the result in a global variable.  I just don't know yet
// how to do this.
const char* lnjscheme_eval_receive_result()
{
  static const char *str = NULL;
  static jstring jstr = NULL;
  static jmethodID method = 0;
  JNIEnv *env = GetJNIEnv();
  if (env) {
    if(jstr) { (*env)->ReleaseStringUTFChars(env, jstr, str); jstr = NULL; }
    if(!method) {
      method = (*env)->GetMethodID(env, main_class, "LNjSchemeResult", "()Ljava/lang/String;");
      if(!method) {
        LOGE("lnjscheme_eval_receive_result LNjSchemeResult not found; main_class: %p", main_class);
        JNI_forward_exception_to_gambit(env);
        return "E \"JNI: method LNjSchemeResult not found\"";
      }
    }
    jstr = (jstring) (*env)->CallObjectMethod(env, globalObj, method);
    str  = jstr ? (*env)->GetStringUTFChars(env, jstr, 0) : NULL;
    // (*env)->ReleaseStringUTFChars(env, jstr, str);  // we do it upon next call
    /* (*env)->DeleteLocalRef(env, method); */
    JNI_forward_exception_to_gambit(env);
  }
  return str;
}

/* EOF ln_jscheme */
