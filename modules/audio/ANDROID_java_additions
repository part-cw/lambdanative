/* modules/audio/ANDROID_java_additions -*- mode: java; c-basic-offset: 2; -*- */

class AudioHelper {
  final static String TAG = "@SYS_PACKAGE_DOT@";
  private static class MediaPlayerHelper {
    private static enum PlayState {
      STOPPED, PREPARED, PLAYING, LOOPING, PAUSED;
    }
    private final MediaPlayer player;
    private PlayState playState;
    public MediaPlayerHelper(Context context, int resId){
      this.player = MediaPlayer.create(context, resId);
      this.playState = PlayState.PREPARED;
      MediaPlayer.OnCompletionListener listener = new MediaPlayer.OnCompletionListener(){
        @Override
        public void onCompletion(MediaPlayer mp){
          playState = PlayState.STOPPED;
          mp.stop();
        }
      };
      this.player.setOnCompletionListener(listener);
    }
    public void release(){
      this.player.release();
    }
    public void start(float lv, float rv, int loop){
      if(this.playState == PlayState.STOPPED){
        try {
          this.player.prepare();
          this.playState = PlayState.PREPARED;
        } catch (IOException e) {
          Log.e(TAG,Log.getStackTraceString(e));
        }
      }
      this.player.setVolume(lv, rv);
      this.player.seekTo(0);
      if(loop != 0){
        this.player.setLooping(true);
        this.playState = PlayState.LOOPING;
      } else {
        this.player.setLooping(false);
        this.playState = PlayState.PLAYING;
      }
      this.player.start();
    }
    public void stop(){
      this.playState = PlayState.STOPPED;
      this.player.stop();
    }
    public void pause(){
      if(this.playState == PlayState.PLAYING || this.playState == PlayState.LOOPING){
        this.player.pause();
        this.playState = PlayState.PAUSED;
      }
    }
    public void resume(){
      if(this.playState == PlayState.PAUSED){
        this.player.start();
        if(this.player.isLooping()){
          this.playState = PlayState.LOOPING;
        } else {
          this.playState = PlayState.PLAYING;
        }
      }
    }
  }
  private static String ResourceLocation = "@SYS_PACKAGE_DOT@:raw/";
  private Context context = null;
  private static AudioHelper instance = null;
  private MediaPlayer mediaPlayer = null;
  private List<MediaPlayerHelper> mediaPlayers = null;
  private AudioManager audioManager = null;
  /*
   * To cache IDs when a class is loaded, and automatically re-cache
   * them if the class is ever unloaded and reloaded: use a class
   * initializer to allow the native code to cache some field
   * offsets. This native function looks up and caches interesting
   * class/field/method IDs. Throws on failure.
   */
  private static native void nativeInit();
  static {
    nativeInit();
  }
  private native void nativeSetInstance();
  private @SYS_APPNAME@ mActivity = null;
  private AudioHelper(@SYS_APPNAME@ forActivity) {
    mActivity = forActivity;
    mediaPlayers = new ArrayList<MediaPlayerHelper>();
    nativeSetInstance();
  }
  public void finalize() {
    for(MediaPlayerHelper mp : mediaPlayers){
      if(mp!=null){
        mp.release();
      }
    }
  }
  public void setContext(Context context, MediaPlayer mediaPlayer){
    this.context = context;
    this.audioManager = (AudioManager) context.getSystemService(Activity.AUDIO_SERVICE);
    this.mediaPlayer = mediaPlayer;
  }
  public static AudioHelper createInstance(@SYS_APPNAME@ forActivity){
    if (instance == null){
      instance = new AudioHelper(forActivity);
    }
    return instance;
  }
  public static AudioHelper getInstance() {
    if (instance == null){
      Log.e(TAG, "AudioHelper_getInstance get before create");
    }
    return instance;
  }
  private int doLoadSound(String filename, int Priority) {
    String s = ResourceLocation + filename;
    int resID = context.getResources().getIdentifier(s, null, null);
    Log.d(TAG,"Entered load sound method.");
    if (resID == 0) {
      Log.e(TAG,"Failed to load sound resource=" + s);
      return 0;
    }
    MediaPlayerHelper localMediaPlayer = new MediaPlayerHelper(context, resID);
    mediaPlayers.add(localMediaPlayer);
    Log.e(TAG, "Sound " + filename + " is # " + mediaPlayers.size());
    System.err.println(TAG + ": Sound " + filename + " is # " + mediaPlayers.size());
    return mediaPlayers.size();
  }
  public int LoadSound(final String filename, final int Priority) {
    java.util.concurrent.FutureTask<Integer> job = new java.util.concurrent.FutureTask<Integer>
      (new java.util.concurrent.Callable<Integer>() {
        @Override
        public Integer call() throws Exception {
          return doLoadSound(filename, Priority); }
      });
    mActivity.runOnUiThread(job);
    try {
      return job.get().intValue();
    } catch (Exception e) {
      return 0; // FIXME, should we retry?
    }
  }
  private void fromNativeLoadSound(final int replyID, final String filename, final int Priority) {
    // We can NOT call LoadSound from a native thread in a situation
    // which MUST NOT block.  The job done within the Java environment
    // by FutureTask above needs to be replicated between Java Threads and
    // corresponding Gambit threads.
    mActivity.runOnUiThread(new Runnable() {
        public void run() {
          mActivity.nativeEvent(126, replyID, doLoadSound(filename, Priority));
        }});
  }
  private int doPlaySound(int SoundID, float lv, float rv, int priority, int loop, float rate) {
    MediaPlayerHelper localMediaPlayer = mediaPlayers.get(SoundID-1);
    if(localMediaPlayer!=null){
      localMediaPlayer.start(lv, rv, loop);
    }
    return SoundID;
  }
  public int PlaySound(final int SoundID, final float lv, final float rv,
                       final int priority, final int loop, final float rate) {
    mActivity.runOnUiThread(new Runnable() {
        public void run() {
          doPlaySound(SoundID, lv, rv, priority, loop, rate);
        }
      });
    return SoundID;
  }
  public int StopSound(final int SoundID) {
    mActivity.runOnUiThread(new Runnable() {
        public void run() {
          MediaPlayerHelper localMediaPlayer = mediaPlayers.get(SoundID-1);
          if(localMediaPlayer!=null) {
            localMediaPlayer.stop();
          }
        }
        });
    return SoundID;
  }
  public int StopAll() {
    final AudioHelper here = this;
    // FIXME: bad example
    java.util.concurrent.FutureTask<Integer> job = new java.util.concurrent.FutureTask<Integer>
      (new java.util.concurrent.Callable<Integer>() {
          @Override
          public Integer call() throws Exception {
            int ct=0;
            for(MediaPlayerHelper player : here.mediaPlayers){
              if(player!=null){
                player.stop();
                ct++;
              }
            }
            return ct;
          }
        });
    mActivity.runOnUiThread(job);
    try {
      return job.get();
    } catch (Exception e) {
      return 0; // FIXME, should we retry?
    }
  }
  public boolean UnloadSound(final int SoundID) {
    // We null out removed sounds - we have to null check sounds
    // later but this simplifies the representation of sounds by
    // their offset index.
    mActivity.runOnUiThread(new Runnable() {
        public void run() {
          MediaPlayerHelper toRemove = mediaPlayers.get(SoundID-1);
          toRemove.release();
          mediaPlayers.set(SoundID-1, null);
        }});
    return true;
  }
  public void onPause(){
    for(MediaPlayerHelper player : this.mediaPlayers){
      if(player!=null){
        player.pause();
      }
    }
  }
  public void onResume(){
    for(MediaPlayerHelper player : this.mediaPlayers){
      if(player!=null){
        player.resume();
      }
    }
  }
  public boolean SetVolume(final float volume){
    float systemMaxVolume = audioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC);
    float systemVolume = audioManager.getStreamVolume(AudioManager.STREAM_MUSIC)/systemMaxVolume;
    if (Math.abs(systemVolume-volume)*100 >= 1) {
      float playerVolume = volume/systemVolume;
      this.mediaPlayer.setVolume(playerVolume,playerVolume);
    }
    return true;
  }
}
// eof AudioHelper
